---
title: "Saqr_regime_Switching"
output: html_document
date: "2023-08-25"
---

```{r setup, include=FALSE}

# Ensure the 'tna' package (Sonsoleslp's version with ts_plots) is installed if needed.
# remotes::install_github("sonsoleslp/tna@ts_plots", force=TRUE)

# Source custom R scripts
source("visibility_graph.R") # For creating visibility graphs
source("seriesplot.R")       # For plotting time series
source("communities.R")      # For community detection in graphs

# Load required libraries
library(tidyverse) # For data manipulation and visualization
library(tna)       # For temporal network analysis
library(rio)       # For easy data import

# Read the full dataset
full_timeseries_data <- rio::import("Var9.csv")

# Filter data for a specific user ("Moti_P01")
user_moti_p01_pleasure_data <- full_timeseries_data %>%
  filter(User == "Moti_P01")

```




```{r}

# --- Visibility Graph Examples ---
# This chunk demonstrates creating different types of visibility graphs
# using the 'pleasure' variable from the filtered time series data.

# Extract the 'pleasure' time series for graph construction
pleasure_series <- user_moti_p01_pleasure_data$pleasure

# 1. Standard Natural Visibility Graph (NVG)
# Output as an adjacency matrix.
natural_visibility_graph_adj <- visibility_graph(pleasure_series)

# 2. Horizontal Visibility Graph (HVG)
# Output as an edge list.
horizontal_visibility_graph_elist <- visibility_graph(pleasure_series,
                                                  method = "hvg",
                                                  output_format = "edgelist")

# 3. Limited Penetrable Visibility Graph (LPVG)
# Allows up to 2 points to obstruct visibility.
limited_penetrable_vg_2 <- visibility_graph(pleasure_series,
                                           penetrable = 2)

# 4. Visibility Graph with Decay
# Visibility strength decreases with the distance between time points.
decay_natural_vg <- visibility_graph(pleasure_series,
                                    decay_factor = 0.1)

# 5. Complex Visibility Graph
# Combines several options: directed, limited penetrability, decay, and limited distance.
complex_custom_vg <- visibility_graph(pleasure_series,
                                     directed = TRUE,
                                     penetrable = 1,
                                     decay_factor = 0.05,
                                     limit = 20) # Max distance for visibility


```


```{r}
# --- Comparison with ts2net Package ---
# This chunk compares a directed Natural Visibility Graph generated by
# the custom 'visibility_graph' function with one from the 'ts2net' package.

# Install 'ts2net' package from GitHub if not already installed
# remotes::install_github("lnferreira/ts2net")
library(ts2net) # For time series to network conversion

# If you meant to use 'user_moti_p01_pleasure_data$pleasure', please adjust.
comparison_series <- pleasure_series

# Generate NVG using ts2net package
ts2net_nv_graph <- ts2net::tsnet_vg(x = comparison_series,
                                  method = "nvg",
                                  directed = TRUE)

# Generate NVG using our custom visibility_graph function
custom_nv_graph_output <- visibility_graph(comparison_series,
                                        method = "nvg",
                                        directed = TRUE)

# Convert our custom graph's adjacency matrix to an igraph object for comparison
custom_igraph_object <- igraph::graph_from_adjacency_matrix(custom_nv_graph_output$matrix)

# Calculate the sum of differences between the adjacency matrices

matrix_difference_sum <- sum(as.matrix(ts2net_nv_graph) - as.matrix(custom_igraph_object))
print(paste("Sum of differences in adjacency matrices:", matrix_difference_sum))

```


```{r}
# --- Network Analysis ---
# This chunk computes network centralities, properties, and communities
# for the directed Natural Visibility Graph 

# Create a tna object from the adjacency matrix of our custom NVG.
# A small epsilon is added for numerical stability if required by tna functions.
visibility_graph_tna_obj <- tna(custom_nv_graph_output$matrix + 0.00000000001)

# Detect communities within the graph
graph_communities <- tna::communities(visibility_graph_tna_obj)

# Plot the detected communities
# Uses a spring layout, hides edge labels, and sets a threshold for displaying edges.
plot(graph_communities,
     layout = "spring",
     edge.labels = FALSE,
     threshold = 0.01)

# Calculate various centrality measures and normalize them
# Arranges the results by Diffusion centrality in descending order.
graph_centralities <- centralities(visibility_graph_tna_obj, normalize = TRUE) %>%
  arrange(desc(Diffusion))

# Display a summary of the tna graph object (e.g., nodes, edges, density)
summary(visibility_graph_tna_obj)

# Display the calculated centralities
print(head(graph_centralities))

```
```{r}
# --- HVG Community Analysis ---

# Aggregated HVG from pleasure_series.
hvg_aggregated_graph_output <- visibility_graph(pleasure_series, # Input time series
                                             method = "hvg",
                                             directed = TRUE,
                                             aggregate = TRUE)

# HVG tna object (add small epsilon for stability).
hvg_tna_object <- tna(hvg_aggregated_graph_output$matrix + 0.0001)

# Detect communities in HVG.
hvg_communities_info <- tna::communities(hvg_tna_object)

# Combine community assignments with original data.
# Assumes user_moti_p01_pleasure_data is the source dataframe for pleasure_series.
hvg_data_with_communities <- cbind(hvg_communities_info$assignments, user_moti_p01_pleasure_data) %>%
  mutate(state = as.character(walktrap)) # 'walktrap' is community label

# Plot time series with community states.
plot_timeseries(data = hvg_data_with_communities,
                value_col = "pleasure", # Value column
                state_col = "state",    # Community state column
                overlay = "v")

# Plot HVG communities.
hvg_community_plot_details <- plot(hvg_communities_info,
                                 edge.labels = FALSE, # No edge labels
                                 threshold = 0.01,    # Edge display threshold
                                 layout = "spring")   # Spring layout

# Create HVG community network.
hvg_community_network_graph <- create_community_network(
  as.data.frame(hvg_aggregated_graph_output$edge_list), # HVG edge list
  node_community_df = hvg_communities_info$assignments  # Node communities
)

# Visualize HVG community network with qgraph.
qgraph::qgraph(hvg_community_network_graph$edge_list,
               color = unique(hvg_community_plot_details$Arguments$color), # Consistent colors
               cut = 0.01)                                                # Edge display threshold
```



```{r}
# --- NVG Community Analysis ---

# Aggregated NVG from pleasure_series.
nvg_aggregated_graph_output <- visibility_graph(pleasure_series, # Input time series
                                             method = "nvg",
                                             directed = TRUE,
                                             aggregate = TRUE)

# NVG tna object (add small epsilon for stability).
nvg_tna_object <- tna(nvg_aggregated_graph_output$matrix + 0.0001)

# Detect communities in NVG.
nvg_communities_info <- tna::communities(nvg_tna_object)

# Combine community assignments with original data.
# Assumes user_moti_p01_pleasure_data is the source dataframe for pleasure_series.
nvg_data_with_communities <- cbind(nvg_communities_info$assignments, user_moti_p01_pleasure_data) %>%
  mutate(state = as.character(walktrap)) # 'walktrap' is community label

# Plot time series with community states.
plot_timeseries(data = nvg_data_with_communities,
                value_col = "pleasure", # Value column
                state_col = "state",    # Community state column
                overlay = "v")

# Plot NVG communities.
nvg_community_plot_details <- plot(nvg_communities_info,
                                 edge.labels = FALSE, # No edge labels
                                 threshold = 0.01,    # Edge display threshold
                                 layout = "spring")   # Spring layout

# Create NVG community network.
nvg_community_network_graph <- create_community_network(
  as.data.frame(nvg_aggregated_graph_output$edge_list), # NVG edge list
  node_community_df = nvg_communities_info$assignments  # Node communities
)

# Visualize NVG community network with qgraph.
qgraph::qgraph(nvg_community_network_graph$edge_list,
               color = unique(nvg_community_plot_details$Arguments$color), # Consistent colors
               cut = 0.01)                                                # Edge display threshold
```










